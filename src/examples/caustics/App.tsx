import {
  PerspectiveCamera,
  PerformanceMonitor,
  useGLTF,
  Environment,
  Lightformer,
  AccumulativeShadows,
  RandomizedLight,
  Caustics,
  Center,
  MeshTransmissionMaterial,
} from "@react-three/drei";
import { Canvas, useFrame } from "@react-three/fiber";
import { easing } from "maath";
import { useRef, useState, type JSX } from "react";
import {
  AdditiveBlending,
  MeshStandardMaterial,
  type Group,
  type Mesh,
  type MeshBasicMaterial,
  type MeshPhysicalMaterial,
} from "three";

export default function App() {
  const [dpr, setDpr] = useState(1.5);
  return (
    <Canvas shadows dpr={dpr} camera={{ position: [20, 0.9, 20], fov: 26 }}>
      <PerformanceMonitor
        onIncline={() => {
          console.log("incline");
          setDpr(1.5);
        }}
        onDecline={() => {
          console.log("decline");
          setDpr(1);
        }}
      />
      <color attach="background" args={["#000000"]} />
      <group position={[0, -0.5, 0]} rotation={[0, -0.75, 0]}>
        <Scene />
        <AccumulativeShadows
          frames={100}
          alphaTest={0.85}
          opacity={0.8}
          color="red"
          scale={20}
          position={[0, -0.005, 0]}
        >
          <RandomizedLight
            amount={8}
            radius={6}
            ambient={0.5}
            intensity={1}
            position={[-1.5, 2.5, -2.5]}
            bias={0.001}
          />
        </AccumulativeShadows>
      </group>
      <Env />
    </Canvas>
  );
}

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
const innerMaterial = new MeshStandardMaterial({
  transparent: true,
  color: "black",
  roughness: 0,
  blending: AdditiveBlending,
  polygonOffset: true,
  polygonOffsetFactor: 1,
  envMapIntensity: 2,
});
type GLTFResult = {
  nodes: {
    glass: Mesh;
    glass_back: Mesh;
    cake: Mesh;
    straw_1: Mesh;
    straw_2: Mesh;
    glass_inner: Mesh;
    straw001_1: Mesh;
    straw001_2: Mesh;
    flowers: Mesh;
    fork: Mesh;
  };
  materials: {
    glass_accurate: MeshPhysicalMaterial;
    FruitCakeSlice_u1_v1: MeshBasicMaterial;
    straw_2: MeshStandardMaterial;
    straw_1: MeshStandardMaterial;
    ["draifrawer_u1_v1.001"]: MeshStandardMaterial;
    ForkAndKnivesSet001_1K: MeshStandardMaterial;
  };
};
export function Scene(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF(
    "/caustics/glass-transformed.glb"
  ) as unknown as GLTFResult;
  return (
    <group {...props} dispose={null}>
      <Caustics
        backside
        causticsOnly={false}
        color={[1, 0.8, 0.8]}
        lightSource={[-1.2, 3, -2]}
        intensity={0.005}
        worldRadius={0.1126 / 10}
        ior={0.91}
        backsideIOR={1.26}
      >
        <mesh castShadow receiveShadow geometry={nodes.glass.geometry}>
          <MeshTransmissionMaterial
            backside
            backsideThickness={0.1}
            thickness={0.05}
            chromaticAberration={0.05}
            anisotropicBlur={1}
            clearcoat={0.5}
            clearcoatRoughness={1}
            envMapIntensity={1.5}
          />
        </mesh>
      </Caustics>
      <mesh
        scale={[0.95, 1, 0.95]}
        castShadow
        geometry={nodes.glass_back.geometry}
        material={innerMaterial}
      />
      <mesh
        castShadow
        geometry={nodes.cake.geometry}
        material={materials.FruitCakeSlice_u1_v1}
      />
      <mesh
        castShadow
        geometry={nodes.glass_inner.geometry}
        material={innerMaterial}
      />
      <Center rotation={[0, -0.4, 0]} position={[-1, -0.01, -2]} top>
        <mesh
          scale={1.2}
          castShadow
          geometry={nodes.flowers.geometry}
          material={materials["draifrawer_u1_v1.001"]}
        />
      </Center>
      <mesh
        castShadow
        geometry={nodes.fork.geometry}
        material={materials.ForkAndKnivesSet001_1K}
      />
      <group position={[3.688, 3.486, 2.086]} rotation={[1.272, 0.497, -0.997]}>
        <PerspectiveCamera
          makeDefault={false}
          far={100}
          near={0.1}
          fov={22.895}
          rotation={[-Math.PI / 2, 0, 0]}
        />
      </group>
      <mesh
        castShadow
        geometry={nodes.straw_1.geometry}
        material={materials.straw_2}
      />
      <mesh
        castShadow
        geometry={nodes.straw_2.geometry}
        material={materials.straw_1}
      />
      <mesh
        castShadow
        geometry={nodes.straw001_1.geometry}
        material={materials.straw_2}
      />
      <mesh
        castShadow
        geometry={nodes.straw001_2.geometry}
        material={materials.straw_1}
      />
    </group>
  );
}
useGLTF.preload("/caustics/glass-transformed.glb");

function Env() {
  const ref = useRef<Group>(null);
  useFrame((state, delta) => {
    if (ref.current) {
      easing.dampE(
        ref.current.rotation,
        [Math.PI / 2, 0, state.clock.elapsedTime / 5 + state.pointer.x],
        0.2,
        delta
      );
    }
    easing.damp3(
      state.camera.position,
      [
        Math.sin(state.pointer.x / 4) * 9,
        state.pointer.y + 1.25,
        Math.cos(state.pointer.x / 4) * 9,
      ],
      0.5,
      delta
    );
    state.camera.lookAt(0, 0, 0);
  });
  return (
    <Environment
      frames={Infinity}
      preset="city"
      background
      blur={0.8}
      resolution={256}
    >
      <Lightformer
        color="red"
        intensity={4} // power level (optional = 1)
        scale={[10, 10, 1]} // Scale it any way you prefer (optional = [1, 1])
        rotation-x={Math.PI / 2}
        position={[0, 5, -9]}
      />
      <Lightformer
        color="red"
        intensity={4} // power level (optional = 1)
        scale={[10, 10, 1]} // Scale it any way you prefer (optional = [1, 1])
        rotation-x={Math.PI / 2}
        position={[0, 5, -9]}
      />
      <group rotation={[Math.PI / 2, 1, 0]}>
        {[2, -2, 2, -4, 2, -5, 2, -9].map((x, i) => (
          <Lightformer
            color="red"
            key={i}
            intensity={1}
            rotation={[Math.PI / 4, 0, 0]}
            position={[x, 4, i * 4]}
            scale={[4, 1, 1]}
          />
        ))}
        <Lightformer
          color="red"
          intensity={0.5}
          rotation-y={Math.PI / 2}
          position={[-5, 1, -1]}
          scale={[50, 2, 1]}
        />
        <Lightformer
          color="red"
          intensity={0.5}
          rotation-y={Math.PI / 2}
          position={[-5, -1, -1]}
          scale={[50, 2, 1]}
        />
        <Lightformer
          color="red"
          intensity={0.5}
          rotation-y={-Math.PI / 2}
          position={[10, 1, 0]}
          scale={[50, 2, 1]}
        />
      </group>
      <group ref={ref}>
        <Lightformer
          intensity={5}
          form="ring"
          color="red"
          rotation-y={Math.PI / 2}
          position={[-5, 2, -1]}
          scale={[10, 10, 1]}
        />
      </group>
    </Environment>
  );
}
